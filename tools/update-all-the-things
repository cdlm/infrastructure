#!env ruby
#
# TODO: document with the literate-code-webpage thing (rocco)

class Update

  OPTION_DEFAULTS = {
    dry_run: false,
    sudo: false,
    nice: false
  }

  def initialize options={}
    @options = OPTION_DEFAULTS.merge(options)
  end

  def nice?()  @options[:nice]  end
  def sudo?()  @options[:sudo]  end
  def dry_run?()  @options[:dry_run]  end
  def skip?()  dry_run?  end

  def describe indent
    desc = @options[:description]
    skipped = if skip? then ' (skipped)' else '' end
    $stderr.puts "#{'  ' * indent}#{desc}#{skipped}" unless desc.nil?
  end
end

class SingleUpdate < Update
  def initialize words, options={}
    super options
    @words = words
    @result = false
    @options[:description] ||= @words.join ' '
    @command_available = system("which #{@words.first} > /dev/null 2>&1")
  end

  def skip?()  super || !@command_available  end

  def command
    (sudo? ? ['sudo'] : []) + (nice? ? ['nice'] : []) + @words
  end

  def run indent=0
    describe indent
    system *command unless skip?
    @result = skip? || $?.success?
  end

  def success?()  @result  end
end

class Updates < Update
  def initialize options={}
    super options
    @things = []
    @results = []
    yield self
  end

  def self.run *args, &block
    all_the_things = self.new(*args, &block)
    success = all_the_things.run
    all_the_things.notify success
    exit success ? 0 : 1
  end

  def group options={}, &block
    @things << Updates.new(@options.merge(options), &block)
  end

  def seq options={}, &block
    @things << DependentUpdates.new(@options.merge(options), &block)
  end

  def step words, options={}
    @things << SingleUpdate.new(words, @options.merge(options))
  end

  def sub_indent
    @options.has_key?(:description) ? 1 : 0
  end

  def run indent=0
    describe indent
    @results = @things.collect do |t| t.run(indent + sub_indent) end
    success?
  end

  def success?()  @results.all?  end

  def notify success
    message = if success
                "Successfully upgraded all the things!"
              else
                "Failed to upgrade all the things :("
              end
    require 'terminal-notifier'
    if ::TerminalNotifier.available?
      ::TerminalNotifier.remove :update_all_the_things
      ::TerminalNotifier.notify message,
        title: 'Tools upgrade',
        subtitle: 'Now get back to actual work',
        group: :update_all_the_things
    end
  rescue LoadError
  ensure
    if success && $stderr.tty? && require('lolcat')
      $stdout = $stderr
      Lol.println message,
        os: rand(256),
        spread: 3.0,
        freq: 0.1
    else
      $stderr.puts message
    end
  end
end

class DependentUpdates < Updates
  def run indent=0
    describe indent
    @things.each do |t|
      @results << t.run(indent + sub_indent)
      break unless t.success?
    end
    success?
  end
end

Updates.run nice: true do |g|
  g.step %w(vim +BundleUpdate +qa)
  g.step %w(tlmgr update --self --all)
  g.step %w(gem update)
  g.seq do |brew|
    brew.step %w(brew update)
    brew.step %w(brew upgrade)
    brew.step %w(brew cleanup)
  end
  g.step %w(cabal update)
  g.seq do |opam|
    opam.step %w(opam update)
    opam.step %w(opam upgrade)
  end
end

